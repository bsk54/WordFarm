<!DOCTYPE html>
<html lang="en">

<!--************************************************************************************************************-->
<!--******************************************* Word Farm ******************************************************-->
<!--**************************************** November 17, 2024 *************************************************-->
<!--************************************************************************************************************-->
<!--******************************************* Version 1.03 ****************************************************-->
<!--**************************************** November 19, 2024 *************************************************-->
<!--************************************************************************************************************-->
<!---------------------------------------------------------------------------------------------------------------->
<!------------------------------------ Code by: Bernd Sebastian Kamps -------------------------------------------->
<!---------------------------------------------------------------------------------------------------------------->
<!-- Description: Word Farm is a web-based tool designed to facilitate text analysis and vocabulary management. -->
<!-- Users can input text, click on words to select them, track clicked items, and export their selections.  ----->
<!-- The application offers a user-friendly interface with features like copy to clipboard. ---------------------->
<!--************************************************************************************************************-->
<!-- License: Word Farm is released under the MIT License. Free for personal and commercial use, ----------------->
<!-- as long as proper credit is given. See LICENSE.txt in the project repository for more details. -------------->
<!--************************************************************************************************************-->
<!--************************************************************************************************************-->
<!-- Repository: https://github.com/bsk54/WordFarm.git ----------------------------------------------------------->
<!-- Web site: https://aioPop.com/WordFarm ----------------------------------------------------------------------->
<!--************************************************************************************************************-->
<!-- Acknowledgments: Special thanks to all contributors and the open-source community for support and ----------->
<!-- contributions to this project. ------------------------------------------------------------------------------>
<!--************************************************************************************************************-->
<!-- Note: Word Farm is free and open source. We encourage modifications and sharing, ---------------------------->
<!-- but please give proper credit to the original authors and maintain this header. ----------------------------->
<!--************************************************************************************************************-->

<head>
    <meta charset="UTF-8">
    <title>Word Farm</title>
    <style>
    /* Light Mode Styles (Mid-90s Aesthetic) */
    body {
        background-color: #FFFFFF; /* White background */
        color: #000000; /* Black text */
        font-family: "Courier New", Courier, monospace; /* Monospaced font for mid-90s feel */
        margin: 20px;
    }
    .container {
        max-width: 800px;
        margin: 0 auto;
    }
    textarea {
        width: 100%;
        height: 100px;
        background-color: #F0F0F0;
        color: #000000;
        border: 1px solid #000000;
        padding: 10px;
        font-family: "Courier New", Courier, monospace;
        box-sizing: border-box;
        white-space: pre-wrap; /* Preserve line breaks in textarea */
    }
    button {
        background-color: #E0E0E0;
        color: #000000;
        border: 1px solid #000000;
        padding: 5px 10px;
        cursor: pointer;
        font-family: "Courier New", Courier, monospace;
        margin-top: 10px;
        margin-right: 10px;
    }
    button:hover {
        background-color: #C0C0C0;
    }
    .word {
        cursor: pointer;
        padding: 2px;
        display: inline; /* Retains padding for words */
        transition: color 0.3s ease;
    }
    .character {
        cursor: pointer;
        padding: 0px; /* Removes padding for characters to eliminate spaces */
        display: inline;
        transition: color 0.3s ease;
    }
    .clicked {
        color: red;
    }
    /* Highlighting class for words being spoken */
    .speaking {
        background-color: yellow;
    }
    .clicked-words {
        margin-top: 20px;
        padding: 10px;
        background-color: #F0F0F0;
        border: 1px solid #000000;
    }
    hr {
        border: 0;
        height: 1px;
        background-color: #000000;
        margin: 20px 0;
    }
footer {
    margin-top: 40px;
    text-align: center;
    font-size: 0.9em;
    color: #555555;
}

/* Link Styles within Footer */
footer a:link,
footer a:visited,
footer a:hover,
footer a:focus,
footer a:active {
    color: #555555; /* Ensures link color matches footer text */
    text-decoration: none; /* Removes underline; adjust as needed */
}

/* Optional: Underline on Hover */
footer a:hover {
    text-decoration: underline; /* Adds underline when hovered */
}

/* Optional: Transition for Smooth Effects */
footer a {
    transition: color 0.3s ease, text-decoration 0.3s ease;
}

    label {
        font-family: "Courier New", Courier, monospace;
    }
    .counts {
        margin-top: 10px;
        font-size: 0.9em;
    }
    @media (max-width: 600px) {
        button {
            width: 100%;
            margin-right: 0;
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            flex-direction: column;
        }
    }
    /* Scrollable clicked items list for better usability on small screens */
    #clickedList {
        max-height: 200px;
        overflow-y: auto;
        padding-left: 20px;
    }
    /* Style for the pronounce button */
    .pronounce-button {
        background-color: #E0E0E0;
        border: 1px solid #000000;
        padding: 2px 5px;
        cursor: pointer;
        font-family: "Courier New", Courier, monospace;
        margin-right: 5px;
    }
    .pronounce-button:hover {
        background-color: #C0C0C0;
    }
    /* Style for the speech rate control */
    .speech-rate-control {
        margin-top: 10px;
    }
    .speech-rate-value {
        font-size: 0.9em;
        margin-bottom: 5px;
    }
    /* Additional styles for the language and voice dropdowns */
    select {
        font-family: "Courier New", Courier, monospace;
        padding: 5px;
        margin-top: 10px;
        width: 100%; /* Make dropdowns full width on small screens */
        box-sizing: border-box;
    }
    /* Style for the Pinyin tooltip */
    .pinyin-tooltip {
        position: absolute;
        background-color: #FFFFE0;
        border: 1px solid #000000;
        padding: 2px 5px;
        font-size: 0.9em;
        font-family: "Courier New", Courier, monospace;
        pointer-events: none; /* Makes the tooltip ignore mouse events */
        z-index: 1000;
    }
    </style>
</head>
<body>
    <div class="container">
        <h1>Word Farm</h1>

        <form id="textForm">
            <textarea id="inputText" placeholder="Copy your text here..."></textarea><br>

            <label for="languageSelect">Select Language:</label>
            <select id="languageSelect">
                <!-- Options will be populated in JavaScript -->
            </select><br>

            <!-- Added Voice Selection Dropdown -->
            <label for="voiceSelect">Select Voice (for Chinese Mandarin, German and English UK only)</label>
            <select id="voiceSelect">
                <!-- Options will be populated dynamically -->
            </select><br>

            <div class="speech-rate-control">
                <div class="speech-rate-value">
                    Speech Rate: <span id="speechRateValue">1.0</span>
                </div>
                <input type="range" id="speechRate" min="0.5" max="2" value="1" step="0.1">
            </div>

            <div class="controls">
                <button type="submit">Submit</button>
            </div>
        </form>

        <div class="counts" id="counts">
            <!-- Word/Character counts will appear here -->
        </div>

        <hr>

        <div id="displayArea" style="white-space: pre-wrap;">
            <!-- Processed text with clickable words/characters will appear here -->
        </div>

        <div class="controls">
            <button id="copyButton">Copy to Clipboard</button>
            <button id="startOverButton">Start Over</button>
        </div>

        <div class="clicked-words" id="clickedWords">
            <strong>Clicked Items:</strong>
            <ul id="clickedList">
                <!-- List of clicked words/characters will appear here -->
            </ul>
        </div>

        <footer>
            &copy; 2024 Copyright <a href="https://hiv.net" target="bsk">BSK</a>
        </footer>
    </div>

    <!-- Include your wf.js and data2.js files -->
    <script src="wf.js"></script>
    <script src="data2.js"></script>

    <script>
    // JavaScript Functionality

    // List of languages and their codes
    const availableLanguages = [
        { label: 'Chinese (Mandarin)', code: 'zh-CN' },
        { label: 'Chinese (Cantonese)', code: 'zh-HK' },
        { label: 'Czech', code: 'cs-CZ' },
        { label: 'Danish', code: 'da-DK' },
        { label: 'Dutch', code: 'nl-NL' },
        { label: 'English (US)', code: 'en-US' },
        { label: 'English (UK)', code: 'en-GB' },
        { label: 'Finnish', code: 'fi-FI' },
        { label: 'French (France)', code: 'fr-FR' },
        { label: 'German', code: 'de-DE' },
        { label: 'Greek', code: 'el-GR' },
        { label: 'Hebrew', code: 'he-IL' },
        { label: 'Hindi', code: 'hi-IN' },
        { label: 'Hungarian', code: 'hu-HU' },
        { label: 'Indonesian', code: 'id-ID' },
        { label: 'Italian', code: 'it-IT' },
        { label: 'Japanese', code: 'ja-JP' },
        { label: 'Korean', code: 'ko-KR' },
        { label: 'Malay', code: 'ms-MY' },
        { label: 'Norwegian', code: 'no-NO' },
        { label: 'Polish', code: 'pl-PL' },
        { label: 'Portuguese (Brazil)', code: 'pt-BR' },
        { label: 'Portuguese (Portugal)', code: 'pt-PT' },
        { label: 'Romanian', code: 'ro-RO' },
        { label: 'Russian', code: 'ru-RU' },
        { label: 'Spanish (Mexico)', code: 'es-MX' },
        { label: 'Spanish (Spain)', code: 'es-ES' },
        { label: 'Swedish', code: 'sv-SE' },
        { label: 'Thai', code: 'th-TH' },
        { label: 'Turkish', code: 'tr-TR' },
        { label: 'Vietnamese', code: 'vi-VN' }
    ];

    // Variables to keep track of state
    let clickedItems = [];
    let isCharacterBased = false;
    let currentLanguage = 'en-US';
    let speechRate = 1;
    let originalText = ''; // Variable to store the original text
    let sentenceTokens = []; // Array to store tokens for each sentence

    // Variables for voice selection
    let voices = [];
    let selectedVoice = null;

    // **Parse data2 into a mapping**
    const pinyinMap = {};
    data2.trim().split('\n').forEach(line => {
        const [char, pinyin] = line.trim().split('#');
        if (char && pinyin) {
            pinyinMap[char] = pinyin;
        }
    });

    // Populate the language dropdown
    const languageSelect = document.getElementById('languageSelect');
    availableLanguages.forEach(lang => {
        const option = document.createElement('option');
        option.value = lang.code;
        option.textContent = lang.label;
        languageSelect.appendChild(option);
    });

    // Load settings from local storage
    window.addEventListener('DOMContentLoaded', () => {
        // Load language
        const storedLanguage = localStorage.getItem('wf_language');
        if (storedLanguage && availableLanguages.some(lang => lang.code === storedLanguage)) {
            currentLanguage = storedLanguage;
            languageSelect.value = currentLanguage;
        } else {
            languageSelect.value = 'en-US';
            currentLanguage = 'en-US';
        }
        isCharacterBased = isCharacterBasedLanguage(currentLanguage);

        // Load speech rate
        const storedSpeechRate = localStorage.getItem('wf_speed');
        if (storedSpeechRate) {
            speechRate = parseFloat(storedSpeechRate);
            speechRateInput.value = speechRate;
            speechRateValue.textContent = speechRate.toFixed(1);
        } else {
            speechRateInput.value = 1;
            speechRateValue.textContent = '1.0';
        }

        // Populate voice list
        populateVoiceList();
    });

    // Function to populate voice list
    function populateVoiceList() {
        voices = speechSynthesis.getVoices();

        // Some browsers may return an empty array initially
        if (voices.length === 0) {
            // Retry after a short delay
            setTimeout(populateVoiceList, 100);
            return;
        }

        updateVoiceOptions();
    }

    // Function to update voice options based on selected language
    function updateVoiceOptions() {
        const voiceSelect = document.getElementById('voiceSelect');
        voiceSelect.innerHTML = ''; // Clear existing options

        // Filter voices by selected language
        const filteredVoices = voices.filter(voice => voice.lang === currentLanguage);

        filteredVoices.forEach((voice, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = `${voice.name} (${voice.lang})`;
            voiceSelect.appendChild(option);
        });

        // Set the selected voice to the first available voice
        if (filteredVoices.length > 0) {
            // Load selected voice from localStorage if available
            const storedVoiceURI = localStorage.getItem('wf_voice');
            const matchingVoice = filteredVoices.find(voice => voice.voiceURI === storedVoiceURI);
            if (matchingVoice) {
                selectedVoice = matchingVoice;
                voiceSelect.selectedIndex = filteredVoices.indexOf(matchingVoice);
            } else {
                voiceSelect.selectedIndex = 0;
                selectedVoice = filteredVoices[0];
                localStorage.setItem('wf_voice', selectedVoice.voiceURI);
            }
        } else {
            selectedVoice = null;
        }
    }

    // Event listener for when the voices have changed (needed for some browsers)
    speechSynthesis.onvoiceschanged = populateVoiceList;

    // Update current language when selection changes
    languageSelect.addEventListener('change', function() {
        currentLanguage = this.value;
        isCharacterBased = isCharacterBasedLanguage(currentLanguage);
        localStorage.setItem('wf_language', currentLanguage);
        updateVoiceOptions(); // Update voice options when language changes
    });

    // Update selected voice when the voice selection changes
    document.getElementById('voiceSelect').addEventListener('change', function() {
        const voiceIndex = parseInt(this.value);
        const filteredVoices = voices.filter(voice => voice.lang === currentLanguage);
        selectedVoice = filteredVoices[voiceIndex];
        if (selectedVoice) {
            localStorage.setItem('wf_voice', selectedVoice.voiceURI);
        }
    });

    // Update speech rate when slider changes
    const speechRateInput = document.getElementById('speechRate');
    const speechRateValue = document.getElementById('speechRateValue');
    speechRateInput.addEventListener('input', function() {
        speechRate = parseFloat(this.value);
        speechRateValue.textContent = speechRate.toFixed(1);
        localStorage.setItem('wf_speed', speechRate);
    });

    // Function to handle form submission
    document.getElementById('textForm').addEventListener('submit', function(event) {
        event.preventDefault(); // Prevent page reload

        // Clear previous data
        document.getElementById('displayArea').innerHTML = '';
        clickedItems = [];
        document.getElementById('clickedList').innerHTML = '';
        updateCounts();

        // Get input text
        const text = document.getElementById('inputText').value;
        const trimmedText = text.trim();

        if (trimmedText === '') {
            alert('Please enter some text.');
            return;
        }

        // Store the original text for later use
        originalText = text;

        // Get selected language and determine if it's character-based
        currentLanguage = languageSelect.value;
        isCharacterBased = isCharacterBasedLanguage(currentLanguage);

        // Split text into sentences for display and processing
        const sentences = splitIntoSentences(text);

        // Update counts
        const total = isCharacterBased ? Array.from(text.replace(/\s+/g, '')).length : countWords(text);
        const countsDiv = document.getElementById('counts');
        countsDiv.innerHTML = `Total ${isCharacterBased ? 'Characters' : 'Words'}: ${total} | Clicked Items: ${clickedItems.length}`;

        const displayArea = document.getElementById('displayArea');

        // Process each sentence
        sentences.forEach((sentence, sentenceIndex) => {
            const lineDiv = document.createElement('div');
            lineDiv.style.display = 'flex';
            lineDiv.style.alignItems = 'center';
            lineDiv.style.marginBottom = '10px';

            // Pronounce button
            const pronounceButton = document.createElement('button');
            pronounceButton.textContent = '🔊';
            pronounceButton.classList.add('pronounce-button');
            lineDiv.appendChild(pronounceButton);

            // Process sentence into tokens (words, punctuation, spaces)
            const tokenRegex = /([^\s.,;!?]+|[.,;!?]|\s+)/g;
            let match;
            let tokens = [];
            let tokenIndex = 0;

            while ((match = tokenRegex.exec(sentence)) !== null) {
                const token = match[0];
                const start = match.index;
                const end = match.index + token.length;

                tokens.push({
                    token: token,
                    start: start,
                    end: end,
                    index: tokenIndex,
                    isWord: isWord(token)
                });

                tokenIndex++;
            }

            // Now, create spans for tokens
            const sentenceContentSpan = document.createElement('span');
            tokens.forEach((tokenObj) => {
                const span = document.createElement('span');
                span.textContent = tokenObj.token;
                if (tokenObj.isWord) {
                    span.className = isCharacterBased ? 'character' : 'word';
                }
                span.dataset.index = `${sentenceIndex}-${tokenObj.index}`; // Store the token's position

                // Assign a unique ID to the span
                span.id = `sentence-${sentenceIndex}-token-${tokenObj.index}`;

                // **Add Pinyin tooltip if the character is in the mapping**
                if (currentLanguage === 'zh-CN' || currentLanguage === 'zh-HK') {
                    if (pinyinMap[tokenObj.token]) {
                        span.dataset.pinyin = pinyinMap[tokenObj.token];

                        // Add hover event listeners to display Pinyin
                        span.addEventListener('mouseenter', function() {
                            const tooltip = document.createElement('div');
                            tooltip.className = 'pinyin-tooltip';
                            tooltip.textContent = this.dataset.pinyin;
                            document.body.appendChild(tooltip);

                            // Position the tooltip
                            const rect = this.getBoundingClientRect();
                            tooltip.style.left = rect.left + window.scrollX + 'px';
                            tooltip.style.top = rect.top + window.scrollY - 25 + 'px'; // Adjust as needed
                            this._tooltip = tooltip;
                        });
                        span.addEventListener('mouseleave', function() {
                            if (this._tooltip) {
                                document.body.removeChild(this._tooltip);
                                this._tooltip = null;
                            }
                        });
                    }
                }

                // Add click event listener only if it's a word
                if (tokenObj.isWord) {
                    span.style.cursor = 'pointer';
                    span.addEventListener('click', function() {
                        if (!this.classList.contains('clicked')) {
                            // If not clicked, mark as clicked
                            this.classList.add('clicked');
                            clickedItems.push({ item: tokenObj.token, index: this.dataset.index, element: this });
                        } else {
                            // If already clicked, unmark it
                            this.classList.remove('clicked');
                            // Find and remove the item from clickedItems
                            clickedItems = clickedItems.filter(entry => entry.index !== this.dataset.index);
                        }
                        updateClickedList();
                        updateCounts();
                    });
                }

                sentenceContentSpan.appendChild(span);
            });

            lineDiv.appendChild(sentenceContentSpan);
            displayArea.appendChild(lineDiv);

            // Store the tokens array for this sentence
            sentenceTokens[sentenceIndex] = tokens;

            // Pronounce button event listener (needs to be after tokens are processed)
            pronounceButton.addEventListener('click', function() {
                const utterance = new SpeechSynthesisUtterance(sentence);
                utterance.lang = currentLanguage;
                utterance.rate = speechRate;
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }

                // Access the tokens array for this sentence
                let tokens = sentenceTokens[sentenceIndex];

                // Remove any existing highlights in the sentence
                tokens.forEach((tokenObj) => {
                    const tokenSpan = document.getElementById(`sentence-${sentenceIndex}-token-${tokenObj.index}`);
                    if (tokenSpan) {
                        tokenSpan.classList.remove('speaking');
                    }
                });

                utterance.onboundary = function(event) {
                    if (event.name === 'word') {
                        const charIndex = event.charIndex;

                        // Find the token where charIndex is between start and end
                        const currentToken = tokens.find((t) => charIndex >= t.start && charIndex < t.end);

                        if (currentToken) {
                            // Remove highlights from all tokens
                            tokens.forEach((t) => {
                                const tokenSpan = document.getElementById(`sentence-${sentenceIndex}-token-${t.index}`);
                                if (tokenSpan) {
                                    tokenSpan.classList.remove('speaking');
                                }
                            });

                            // Highlight the current token if it's a word
                            if (currentToken.isWord) {
                                const tokenSpan = document.getElementById(`sentence-${sentenceIndex}-token-${currentToken.index}`);
                                if (tokenSpan) {
                                    tokenSpan.classList.add('speaking');
                                }
                            }
                        }
                    }
                };

                // Remove highlights when speaking ends
                utterance.onend = function() {
                    tokens.forEach((tokenObj) => {
                        const tokenSpan = document.getElementById(`sentence-${sentenceIndex}-token-${tokenObj.index}`);
                        if (tokenSpan) {
                            tokenSpan.classList.remove('speaking');
                        }
                    });
                };

                speechSynthesis.speak(utterance);
            });
        });

        // After processing, set focus back to the textarea
        document.getElementById('inputText').focus();
    });

    // Helper functions
    function isCharacterBasedLanguage(langCode) {
        return ['zh-CN', 'zh-HK', 'ja-JP', 'ko-KR'].includes(langCode);
    }

    function isWord(token) {
        return /^[^\s.,;!?]+$/.test(token);
    }

    function isPunctuation(token) {
        return /^[.,;!?]$/.test(token);
    }

    function isSpace(token) {
        return /^\s+$/.test(token);
    }

    function countWords(text) {
        const words = text.match(/[^\s.,;!?。！？]+/g);
        return words ? words.length : 0;
    }

    // Function to split text into sentences
    function splitIntoSentences(text) {
        // Regular expression to split sentences based on ., !, ?, and Chinese equivalents
        const sentenceEndings = /(?<=[.!?。！？])\s*/g;
        return text.split(sentenceEndings).filter(sentence => sentence.trim() !== '');
    }

    // Function to update the list of clicked items
    function updateClickedList() {
        const list = document.getElementById('clickedList');
        list.innerHTML = ''; // Clear current list

        // Sort clicked items based on their original position
        const sortedClicked = clickedItems.slice().sort((a, b) => {
            const [aSentenceIndex, aTokenIndex] = a.index.split('-').map(Number);
            const [bSentenceIndex, bTokenIndex] = b.index.split('-').map(Number);
            if (aSentenceIndex === bSentenceIndex) {
                return aTokenIndex - bTokenIndex;
            }
            return aSentenceIndex - bSentenceIndex;
        });

        sortedClicked.forEach((entry) => {
            const listItem = document.createElement('li');
            listItem.textContent = entry.item;
            list.appendChild(listItem);
        });
    }

    // Function to update counts
    function updateCounts() {
        const text = document.getElementById('inputText').value;
        const total = isCharacterBased ? Array.from(text.replace(/\s+/g, '')).length : countWords(text);
        const clickedCount = clickedItems.length;
        const countsDiv = document.getElementById('counts');
        countsDiv.innerHTML = `Total ${isCharacterBased ? 'Characters' : 'Words'}: ${total} | Clicked Items: ${clickedCount}`;
    }

    // Function to copy text and clicked items to clipboard
    document.getElementById('copyButton').addEventListener('click', function() {
        if (originalText.trim() === '') {
            alert('No text to copy.');
            return;
        }

        let copiedContent = `Language: ${availableLanguages.find(lang => lang.code === currentLanguage).label}\n`;
        copiedContent += `Voice: ${selectedVoice ? selectedVoice.name : 'Default'}\n`;
        copiedContent += `Speech Rate: ${speechRate.toFixed(1)}\n\n`;
        copiedContent += 'Original Text:\n' + originalText + '\n\nClicked Items:\n';

        if (clickedItems.length === 0) {
            copiedContent += 'None';
        } else {
            // Sort clicked items based on their original position
            const sortedClicked = clickedItems.slice().sort((a, b) => {
                const [aSentenceIndex, aTokenIndex] = a.index.split('-').map(Number);
                const [bSentenceIndex, bTokenIndex] = b.index.split('-').map(Number);
                if (aSentenceIndex === bSentenceIndex) {
                    return aTokenIndex - bTokenIndex;
                }
                return aSentenceIndex - bSentenceIndex;
            });
            sortedClicked.forEach((entry) => {
                copiedContent += entry.item + '\n';
            });
        }

        // Create a temporary textarea to copy the content
        const tempTextarea = document.createElement('textarea');
        tempTextarea.value = copiedContent;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        tempTextarea.setSelectionRange(0, 99999); // For mobile devices

        try {
            document.execCommand('copy');
            alert('Text and clicked items copied to clipboard!');
        } catch (err) {
            alert('Failed to copy text.');
        }

        document.body.removeChild(tempTextarea);
    });

    // Function to reload the page (Start Over)
    document.getElementById('startOverButton').addEventListener('click', function() {
        if (confirm('Are you sure you want to start over? All data will be lost.')) {
            location.reload();
        }
    });
    </script>
</body>
</html>
